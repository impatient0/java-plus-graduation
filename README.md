# Explore With Me (Исследуй со мной)

Приложение-афиша, позволяющее пользователям делиться информацией об интересных событиях и находить компанию для участия в них. Изначально проект был разработан в команде в рамках обучения в Яндекс Практикуме.

В настоящее время проект представляет собой полностью переработанную систему, развитую в рамках индивидуального дипломного проекта. Монолитная архитектура была полностью разделена на независимые микросервисы, управляемые с помощью **Spring Cloud**, а система статистики заменена на **асинхронную, событийно-ориентированную систему рекомендаций**, построенную на **Apache Kafka** и **gRPC**.

## Оглавление

- [Архитектура](#архитектура)
- [Технологии](#технологии)
- [Структура проекта](#структура-проекта)
- [API Спецификации](#api-спецификации)
- [Начало работы](#начало-работы)
    - [Предварительные требования](#предварительные-требования)
    - [Сборка проекта](#сборка-проекта)
    - [Запуск с использованием Docker Compose (Рекомендуемый способ)](#запуск-с-использованием-docker-compose-рекомендуемый-способ)
    - [Локальный запуск для разработки (IntelliJ IDEA)](#локальный-запуск-для-разработки-intellij-idea)
- [Примеры использования API](#примеры-использования-api)
- [История проекта и Автор](#история-проекта-и-автор)

## Архитектура

Приложение построено на основе микросервисной, событийно-ориентированной архитектуры. Инфраструктурные компоненты **Spring Cloud** обеспечивают отказоустойчивость и централизованное управление, а бизнес-логика разделена на независимые сервисы.

#### Инфраструктурные сервисы:

-   **API Gateway (`gateway-server`)**: Единая точка входа для всех внешних REST API запросов.
-   **Discovery Server (`discovery-server`)**: Сервер обнаружения сервисов (Netflix Eureka).
-   **Config Server (`config-server`)**: Сервер централизованной конфигурации.
-   **Apache Kafka**: Брокер сообщений, используемый как основа для асинхронной обработки действий пользователей.

#### Сервисы бизнес-логики:

-   **`event-service`**, **`user-service`**, **`request-service`**, **`comment-service`**: Набор REST-сервисов, реализующих основную бизнес-логику приложения.

#### Система Рекомендаций (асинхронный конвейер обработки данных):

-   **`collector`**: gRPC-сервис, принимающий информацию о действиях пользователей (`VIEW`, `LIKE`, `REGISTER`) и отправляющий ее в топик Kafka.
-   **`aggregator`**: Сервис-обработчик, который слушает топик с действиями, инкрементально пересчитывает косинусное сходство между событиями и публикует результаты в другой топик Kafka.
-   **`analyzer`**: Сервис, который слушает оба топика, сохраняет историю взаимодействий и рассчитанные сходства в свою базу данных, а также предоставляет gRPC API для выдачи рекомендаций.

#### Межсервисное взаимодействие:

-   **Синхронное (REST API):** Внешние клиенты взаимодействуют с системой через API Gateway по REST.
-   **Синхронное (внутреннее):** Для высокопроизводительных запросов к системе рекомендаций (например, `event-service` запрашивает рейтинг) используется **gRPC**, работающий через Eureka.
-   **Асинхронное (события):** Для логирования действий пользователей используется **Apache Kafka** с сообщениями в формате **Avro**.
-   **Общие контракты:**
    -   **`interaction-api`**: Модуль с общими DTO для REST API.
    -   **`serialization`**: Модуль с Avro и Protobuf схемами и сгенерированными классами.
    -   **`stats-client`**: Клиентская библиотека, предоставляющая удобные gRPC-клиенты и AOP-аспекты для взаимодействия с системой рекомендаций.

## Технологии

-   Java 21, Spring Boot 3.5.5
-   **Микросервисы:** Spring Cloud (Gateway, Netflix Eureka, Config)
-   **Асинхронная обработка:** Apache Kafka
-   **Сериализация:** Apache Avro (для Kafka), Protocol Buffers (для gRPC)
-   **RPC:** gRPC
-   **Базы данных:** PostgreSQL 16.1, Spring Data JPA, QueryDSL
-   **Сборка:** Maven
-   **Контейнеризация:** Docker, Docker Compose
-   **Качество кода:** Lombok, MapStruct, Checkstyle, Spotbugs

## Структура проекта

```
explore-with-me/
|
├── core/           (Модули, реализующие бизнес-логику)
│   ├── serialization/    (Avro/Protobuf схемы)
│   ├── stats-client/     (gRPC клиенты и AOP)
│   ├── interaction-api/  (REST DTO)
│   ├── event-service/
│   ├── user-service/
│   ├── request-service/
│   ├── comment-service/
│   ├── collector/
│   ├── aggregator/
│   └── analyzer/
|
└── infra/          (Инфраструктурные сервисы Spring Cloud)
    ├── config-server/
    ├── discovery-server/
    └── gateway-server/
```

## API Спецификации

Внешний REST API, доступный через API Gateway, остался по большей части без изменений, за исключением замены поля `views` на `rating` у событий и добавления новых эндпоинтов для лайков и рекомендаций.

-   **Основной сервис (внешний API):** [`ewm-main-service-spec.json`](https://github.com/impatient0/java-plus-graduation/blob/main/ewm-main-service-spec.json)

## Начало работы

### Предварительные требования

- JDK 21
- Apache Maven 3.6+
- Docker и Docker Compose

### Сборка проекта

Для сборки всех модулей, включая генерацию классов из Avro и Protobuf схем:
```bash
mvn clean install
```

### Запуск с использованием Docker Compose (Рекомендуемый способ)

Это основной способ запуска всего приложения, который поднимает все микросервисы и их зависимости.

1.  **Соберите проект:** `mvn clean install`
2.  **Запустите сервисы:**
    ```bash
    docker-compose up --build
    ```
    Эта команда запустит все инфраструктурные и бизнес-сервисы.

3.  **Доступ к приложению:**
    - **Единая точка входа (REST API):** `http://localhost:8080`
    - **Eureka Dashboard:** `http://localhost:8761`

4.  **Остановка сервисов:**
    ```bash
    docker-compose down -v
    ```

### Локальный запуск для разработки (IntelliJ IDEA)

Локальный запуск требует ручного старта всех сервисов в правильной последовательности. Это полезно для отладки конкретного сервиса.

**Важно:** Все сервисы (кроме `gateway-server` и `discovery-server`) запускаются на случайных портах и получают свою конфигурацию от `config-server`.

**Порядок запуска:**

1.  **`discovery-server`**: Запустите `EurekaServerApp`. Дождитесь полного старта.
2.  **`config-server`**: Запустите `ConfigServerApplication`. Убедитесь, что он зарегистрировался в Eureka.
3.  **Сервисы обработки данных**: Запустите `CollectorApplication`, `AggregatorApplication`, `AnalyzerApplication` (порядок между ними не важен).
4.  **Сервисы бизнес-логики**: Запустите `UserServiceApplication`, `EventServiceApplication`, `CommentServiceApplication`, `RequestServiceApplication` (порядок между ними не важен).
5.  **`gateway-server`**: Запустите `GatewayServerApplication`.

После запуска всех сервисов **все API-запросы** должны направляться на порт API Gateway: `http://localhost:8080`.

## Примеры использования API

### Публичные эндпоинты Событий, Категорий, Подборок

-   **Получение списка событий с фильтрацией:**
    `GET http://localhost:8080/events?text=концерт&categories=1,2&paid=true&rangeStart=2025-06-01 00:00:00&rangeEnd=2025-06-30 23:59:59&onlyAvailable=true&sort=VIEWS&from=0&size=10`
    *(Предполагается, что даты и время URL-кодированы)*

-   **Получение подробной информации о событии:**
    `GET http://localhost:8080/events/{eventId}`

-   **Получение списка категорий:**
    `GET http://localhost:8080/categories?from=0&size=10`

-   **Получение категории по ID:**
    `GET http://localhost:8080/categories/{catId}`

-   **Получение списка подборок:**
    `GET http://localhost:8080/compilations?pinned=true&from=0&size=10`

-   **Получение подборки по ID:**
    `GET http://localhost:8080/compilations/{compId}`

### Публичные эндпоинты Комментариев

-   **Получение списка комментариев к событию:**
    `GET http://localhost:8080/events/{eventId}/comments?from=0&size=10&sort=createdOn,DESC`

### Postman-тесты для Дополнительной Функциональности

Для проверки работоспособности эндпоинтов реализованной дополнительной функциональности "Комментарии" подготовлена Postman-коллекция.

-   **Расположение:** `postman/feature.json` в корне репозитория.
-   **Проверка:** Тесты в коллекции проверяют основные сценарии использования API комментариев, включая коды ответов, базовый формат JSON и значения полей.

### Обзор функционала:

Реализована возможность для пользователей оставлять, редактировать и удалять свои комментарии к опубликованным событиям, а также для администраторов модерировать (удалять, восстанавливать) любые комментарии.

**Ключевые возможности:**

*   **Пользователи (Private API):**
    *   Создание комментария к событию (`POST /users/{userId}/comments?eventId={eventId}`).
        *   Комментарии можно оставлять только к опубликованным событиям, у которых включена опция комментирования.
    *   Редактирование своего комментария (`PATCH /users/{userId}/comments/{commentId}`).
        *   Возможно только в течение 6 часов после создания.
        *   Устанавливается флаг `isEdited`.
    *   "Мягкое" удаление своего комментария (`DELETE /users/{userId}/comments/{commentId}`).
        *   Комментарий помечается как удаленный (`isDeleted = true`), но не удаляется физически.
    *   Получение списка своих комментариев (`GET /users/{userId}/comments`).

*   **Администраторы (Admin API):**
    *   "Мягкое" удаление любого комментария (`DELETE /admin/comments/{commentId}`).
    *   Восстановление "мягко" удаленного комментария (`PATCH /admin/comments/{commentId}/restore`).
    *   Получение списка всех комментариев с фильтрацией (`GET /admin/comments`) по автору, событию, статусу удаления. В ответе (`CommentAdminDto`) передается флаг `isDeleted`.

*   **Все пользователи (Public API):**
    *   Получение списка комментариев для конкретного события (`GET /events/{eventId}/comments`).
        *   Возвращаются только не удаленные комментарии.
        *   Если комментарии к событию отключены (`Event.commentsEnabled = false`), возвращается пустой список.
        *   Поддерживается пагинация и сортировка (по умолчанию по дате создания, сначала новые).

*   **Интеграция с Событиями (`Event`):**
    *   В сущность `Event` добавлено поле `commentsEnabled` (boolean, default `true`), позволяющее инициатору или администратору включать/отключать возможность комментирования для события. Это поле управляется через эндпоинты создания/обновления событий.
    *   Настроено каскадное удаление комментариев при удалении связанного события или автора.

**Детальное описание новых эндпоинтов и DTO для комментариев представлено в обновленной спецификации API `ewm-main-service-spec.json`** (см. раздел [API Спецификации](#api-спецификации)).

## История проекта и Автор

Изначально данный проект был разработан в команде из четырех человек в рамках курса "Java-разработчик" от Яндекс Практикума. Командная работа включала в себя реализацию основного сервиса, сервиса статистики и дополнительной функциональности "Комментарии".

Над командной частью проекта работали:
- Иван Петровский (Team Lead) - [@impatient0](https://github.com/impatient0)
- Андрей Гагарский - [@Gagarskiy-Andrey](https://github.com/Gagarskiy-Andrey)
- Валерия Бутько - [@progingir](https://github.com/progingir)
- Сергей Филипповских - [@SergikF](https://github.com/SergikF)

В настоящее время проект развивается как **индивидуальный дипломный проект** Иваном Петровским. Дальнейшие доработки, рефакторинг и расширение функционала ведутся в рамках данного репозитория.
